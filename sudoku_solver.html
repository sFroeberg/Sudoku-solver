<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sudoku Solver</title>
  <style>
    :root{--cell-size:48px;--gap:4px}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:28px;display:flex;flex-direction:column;align-items:center;gap:18px}
    h1{margin:0;font-size:20px}
    .board{display:grid;grid-template-columns:repeat(9, var(--cell-size));grid-template-rows:repeat(9,var(--cell-size));gap:var(--gap);background:#111;padding:6px;border-radius:12px}
    .cell{width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;background:#fff;border-radius:6px;position:relative}
    .cell input{width:100%;height:100%;text-align:center;border:0;font-size:20px;font-weight:600;outline:none;background:transparent}
    /* thicker borders for 3x3 boxes (by using pseudo elements) */
    .cell::after{content:"";position:absolute;inset:0;border:1px solid rgba(0,0,0,0.08);border-radius:6px;pointer-events:none}
    /* Add heavier borders on box edges */
    .cell[data-r="0"], .cell[data-r="3"], .cell[data-r="6"]{border-top:3px solid #111}
    .cell[data-r="2"], .cell[data-r="5"], .cell[data-r="8"]{border-bottom:3px solid #111}
    .cell[data-c="0"], .cell[data-c="3"], .cell[data-c="6"]{border-left:3px solid #111}
    .cell[data-c="2"], .cell[data-c="5"], .cell[data-c="8"]{border-right:3px solid #111}
    /* status area */
    .controls{display:flex;gap:10px;align-items:center}
    button{padding:8px 12px;border-radius:8px;border:0;background:#0b74ff;color:#fff;font-weight:600;cursor:pointer}
    button.secondary{background:#6b7280}
    .footer{display:flex;gap:12px;align-items:center}
    .msg{min-width:260px;padding:8px 10px;border-radius:8px;background:#f3f4f6;color:#111}
    .invalid{background:#fee2e2;color:#7f1d1d}
    .given input{color:#0b74ff}
    .solved input{color:#111}
    .conflict input{background:#fee2e2}
    .small{font-size:13px;color:#666}
    @media (max-width:520px){:root{--cell-size:34px}body{margin:12px}}
  </style>
</head>
<body>
  <h1>Sudoku Solver — enter givens then click <em>Solve</em></h1>
  <div class="board" id="board"></div>
  <div class="controls">
    <button id="solveBtn">Solve</button>
    <button id="clearBtn" class="secondary">Clear</button>
    <button id="resetGivensBtn" class="secondary">Reset Givens</button>
    <div class="msg" id="message">Enter digits 1–9 or leave blank. Use the grid or paste a 81-char line (see instructions).</div>
  </div>
  <div class="footer small">
    <div>Tip: press a cell then type 1–9. Use Backspace/Delete to clear.</div>
    <div style="margin-left:14px">Want to import? Paste a single 81-character line (use <code>.</code> or <code>0</code> for empties) into the console input (press <kbd>Ctrl+V</kbd> then click 'Solve')</div>
  </div>

  <script>
    // Create 9x9 grid of inputs
    const boardEl = document.getElementById('board');
    const cells = [];
    for (let r=0;r<9;r++){
      for (let c=0;c<9;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        const inp = document.createElement('input');
        inp.inputMode = 'numeric';
        inp.maxLength = 1;
        inp.dataset.r = r; inp.dataset.c = c;
        inp.addEventListener('input', onCellInput);
        inp.addEventListener('keydown', onCellKeyDown);
        cell.appendChild(inp);
        boardEl.appendChild(cell);
        cells.push({r,c,el:cell,input:inp});
      }
    }

    let givensSnapshot = null;

    function onCellInput(e){
      const v = e.target.value.replace(/[^1-9]/g,'').slice(0,1);
      e.target.value = v;
      markGivens();
      clearHighlights();
    }
    function onCellKeyDown(e){
      if (e.key === 'ArrowLeft') moveFocus(-1,0,e.target);
      if (e.key === 'ArrowRight') moveFocus(1,0,e.target);
      if (e.key === 'ArrowUp') moveFocus(0,-1,e.target);
      if (e.key === 'ArrowDown') moveFocus(0,1,e.target);
      // allow delete/backspace to clear
      if (e.key === 'Backspace' || e.key==='Delete'){
        e.target.value = '';
        markGivens();
        clearHighlights();
      }
    }
    function moveFocus(dx,dy,target){
      const r = Number(target.dataset.r);
      const c = Number(target.dataset.c);
      const nr = Math.min(8, Math.max(0, r+dy));
      const nc = Math.min(8, Math.max(0, c+dx));
      const idx = nr*9 + nc;
      cells[idx].input.focus();
    }

    function readGrid(){
      const grid = Array.from({length:9},()=>Array(9).fill(0));
      for (const {r,c,input} of cells){
        const v = parseInt(input.value)||0;
        grid[r][c] = v;
      }
      return grid;
    }
    function writeGrid(grid, markGiven=false){
      for (const {r,c,input,el} of cells){
        const v = grid[r][c];
        input.value = v===0? '': String(v);
        el.classList.toggle('given', markGiven && input.value !== '');
      }
    }

    function markGivens(){
      for (const {input,el} of cells){
        el.classList.toggle('given', input.value !== '');
      }
    }

    function clearHighlights(){
      for (const {el} of cells){ el.classList.remove('conflict','solved'); }
      document.getElementById('message').classList.remove('invalid');
    }

    // Validate initial grid (no duplicates in row/col/box for non-zero cells)
    function validateGrid(grid){
      function hasDup(arr){
        const seen = new Set();
        for (const v of arr){ if (v===0) continue; if (seen.has(v)) return true; seen.add(v);} return false;
      }
      // rows
      for (let r=0;r<9;r++) if (hasDup(grid[r])) return {ok:false,msg:`Duplicate in row ${r+1}`};
      // cols
      for (let c=0;c<9;c++){ const col=[]; for (let r=0;r<9;r++) col.push(grid[r][c]); if (hasDup(col)) return {ok:false,msg:`Duplicate in column ${c+1}`}; }
      // boxes
      for (let br=0;br<3;br++) for (let bc=0;bc<3;bc++){
        const box=[];
        for (let r=0;r<3;r++) for (let c=0;c<3;c++) box.push(grid[br*3+r][bc*3+c]);
        if (hasDup(box)) return {ok:false,msg:`Duplicate in 3x3 box starting at row ${br*3+1}, col ${bc*3+1}`};
      }
      return {ok:true};
    }

    // Sudoku solver: backtracking with simple heuristics (MRV: choose cell with fewest candidates)
    function solveSudoku(grid){
      // deep copy
      const g = grid.map(r=>r.slice());
      function possible(r,c){
        if (g[r][c] !== 0) return [];
        const used = new Set();
        for (let i=0;i<9;i++){ used.add(g[r][i]); used.add(g[i][c]); }
        const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
        for (let i=0;i<3;i++) for (let j=0;j<3;j++) used.add(g[br+i][bc+j]);
        const out = [];
        for (let v=1;v<=9;v++) if (!used.has(v)) out.push(v);
        return out;
      }
      function findEmptyWithFewest(){
        let best=null; let bestOptions=10;
        for (let r=0;r<9;r++) for (let c=0;c<9;c++){
          if (g[r][c]===0){
            const opts = possible(r,c);
            if (opts.length===0) return {r,c,opts};
            if (opts.length < bestOptions){ bestOptions = opts.length; best={r,c,opts}; if (bestOptions===1) return best; }
          }
        }
        return best;
      }
      let steps=0;
      function backtrack(){
        steps++;
        const next = findEmptyWithFewest();
        if (!next) return true; // solved
        const {r,c,opts} = next;
        for (const v of opts){
          g[r][c]=v;
          if (backtrack()) return true;
          g[r][c]=0;
        }
        return false;
      }
      const ok = backtrack();
      return {ok,grid: g, steps};
    }

    // UI handlers
    document.getElementById('solveBtn').addEventListener('click', ()=>{
      clearHighlights();
      const grid = readGrid();
      const v = validateGrid(grid);
      const msgEl = document.getElementById('message');
      if (!v.ok){
        msgEl.textContent = 'Invalid starting grid — ' + v.msg;
        msgEl.classList.add('invalid');
        highlightConflicts(grid);
        return;
      }
      // Save givens snapshot (in case user wants to reset)
      givensSnapshot = readGrid();
      // Solve
      msgEl.textContent = 'Solving...';
      setTimeout(()=>{
        const result = solveSudoku(grid);
        if (!result.ok) { msgEl.textContent = 'No solution found (puzzle is invalid or has no solutions).'; msgEl.classList.add('invalid'); }
        else { writeGrid(result.grid,true); msgEl.textContent = `Solved — steps: ${result.steps}`; }
      }, 10);
    });

    document.getElementById('clearBtn').addEventListener('click', ()=>{
      for (const {input,el} of cells){ input.value=''; el.classList.remove('given'); el.classList.remove('conflict'); }
      givensSnapshot = null; clearHighlights(); document.getElementById('message').textContent = 'Cleared.';
    });
    document.getElementById('resetGivensBtn').addEventListener('click', ()=>{
      if (!givensSnapshot){ document.getElementById('message').textContent = 'No givens snapshot to reset to.'; return; }
      writeGrid(givensSnapshot, true); document.getElementById('message').textContent = 'Reset to saved givens.'; clearHighlights();
    });

    // Highlight duplicate/conflict cells for invalid starting grid (simple approach)
    function highlightConflicts(grid){
      // mark conflicts by scanning rows/cols/boxes
      for (let r=0;r<9;r++){
        const map = new Map();
        for (let c=0;c<9;c++){ const v=grid[r][c]; if (v===0) continue; if (!map.has(v)) map.set(v,[]); map.get(v).push([r,c]); }
        for (const [v,cellsArr] of map.entries()) if (cellsArr.length>1) for (const [rr,cc] of cellsArr) highlight(rr,cc);
      }
      for (let c=0;c<9;c++){
        const map = new Map();
        for (let r=0;r<9;r++){ const v=grid[r][c]; if (v===0) continue; if (!map.has(v)) map.set(v,[]); map.get(v).push([r,c]); }
        for (const [v,cellsArr] of map.entries()) if (cellsArr.length>1) for (const [rr,cc] of cellsArr) highlight(rr,cc);
      }
      for (let br=0;br<3;br++) for (let bc=0;bc<3;bc++){
        const map = new Map();
        for (let r=0;r<3;r++) for (let c=0;c<3;c++){ const rr=br*3+r, cc=bc*3+c; const v=grid[rr][cc]; if (v===0) continue; if (!map.has(v)) map.set(v,[]); map.get(v).push([rr,cc]); }
        for (const [v,cellsArr] of map.entries()) if (cellsArr.length>1) for (const [rr,cc] of cellsArr) highlight(rr,cc);
      }
      function highlight(r,c){ const idx = r*9+c; cells[idx].el.classList.add('conflict'); }
    }

    // Paste/import small format: listen for paste of 81-char line into document
    window.addEventListener('paste', (e)=>{
      const text = (e.clipboardData||window.clipboardData).getData('text');
      const s = text.trim();
      // allow digits and dots/zeros for empties
      const cleaned = s.replace(/[^0-9\.]/g,'');
      if (cleaned.length===81){
        // import
        const arr = cleaned.split('').map(ch=> (ch==='0' || ch==='.' ? 0 : parseInt(ch) ));
        for (let i=0;i<81;i++){ cells[i].input.value = arr[i]===0? '': String(arr[i]); }
        markGivens();
        document.getElementById('message').textContent = '81-char puzzle imported. Click Solve.';
      }
    });

    // On load: set focus to center cell
    window.addEventListener('load', ()=>{ cells[40].input.focus(); });
  </script>
</body>
</html>
